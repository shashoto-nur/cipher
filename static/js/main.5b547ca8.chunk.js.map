{"version":3,"sources":["reportWebVitals.ts","logo.svg","utils/logError.ts","utils/deriveKey.ts","env/variables.ts","utils/getAlgorithm.ts","utils/getFileChunk.ts","utils/shouldRepeat.ts","helpers/encryptFile.ts","helpers/decryptFile.ts","components/Cipher.tsx","App.tsx","index.tsx"],"names":["reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","logError","message","console","log","alert","deriveKey","passkey","a","window","crypto","subtle","importKey","TextEncoder","encode","pbkdf2Key","key","passwordKey","getKey","variables","CHUNK_SIZE","PADDING","IV_SIZE","ALGO","getAlgorithm","repetitons","Math","floor","length","stringVector","repeat","substring","bitVector","name","iv","reader","FileReader","getFileChunk","file","start","end","Promise","resolve","_reject","chunk","slice","readAsArrayBuffer","onloadend","event","target","readyState","DONE","arrayBufferChunk","result","uint8Chunk","Uint8Array","shouldRepeat","fileSize","newEnd","undefined","encryptData","unencryptedData","algorithm","encrypt","encryptedData","encryptedUint8Data","encryptChunkNSave","writer","unencryptedChunk","encryptedChunk","write","size","newStart","close","startEncryption","filename","newName","random","toString","writableStream","createWriteStream","getWriter","filenameArray","encryptedFilename","metaDataLen","metaData","decryptData","decrypt","decryptedData","decryptedUint8Data","decryptChunkNSave","decryptedChunk","paddedEnd","startDecryption","decryptedFilenameArray","TextDecoder","decode","Cipher","useState","setFile","setFilename","setPasskey","src","logo","className","alt","onSubmit","preventDefault","htmlFor","id","tabIndex","onKeyPress","e","document","getElementById","click","type","onChange","files","value","placeholder","onClick","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.5b547ca8.chunk.js","sourcesContent":["import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;","export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","\r\nconst logError = (message: string) =>\r\n{\r\n    console.log(message);\r\n    alert('Operation failed! Please try again...');\r\n}\r\n\r\nexport default logError;","import logError from 'utils/logError';\r\n\r\nconst deriveKey = async (passkey: string) =>\r\n{\r\n    try\r\n    {\r\n        // Create a PBKDF2 key containing the passkey\r\n        const pbkdf2Key = await window.crypto.subtle.importKey(\r\n                \"raw\", new TextEncoder().encode(passkey),\r\n                {\"name\": \"PBKDF2\"}, false, [\"deriveKey\"]\r\n        );\r\n\r\n        // Derive a key from the password key\r\n        const getKey = (passwordKey: CryptoKey) =>\r\n        {\r\n            return window.crypto.subtle.deriveKey({\r\n                    \"name\": \"PBKDF2\", \"salt\": new TextEncoder().encode('salt'),\r\n                    \"iterations\": 1000, \"hash\": 'SHA-256'\r\n                },\r\n                passwordKey,\r\n                { \"name\": \"AES-GCM\", \"length\": 128 },\r\n                true,\r\n                [ \"encrypt\", \"decrypt\" ]\r\n            );\r\n        };\r\n\r\n        const key = getKey(pbkdf2Key);\r\n\r\n        return key;\r\n    }\r\n    catch ({ message }) { logError(message as string); };\r\n};\r\n\r\n\r\nexport default deriveKey;","\r\nconst CHUNK_SIZE = 50 * 1024 * 1024; // 50 megabyte\r\nconst PADDING = 16; // 16 bits padding\r\n\r\nconst IV_SIZE = 12; // 12 bits\r\nconst ALGO = \"AES-GCM\"; // AEAD algorithm\r\n\r\n\r\nconst variables = { CHUNK_SIZE, PADDING, IV_SIZE, ALGO };\r\nexport default variables;","import logError from 'utils/logError';\r\nimport variables from 'env/variables';\r\n\r\n// The algorithm to encrypt the file using webcrypto\r\nconst getAlgorithm = (passkey: string) => \r\n{\r\n    try\r\n    {\r\n        // Get a string of IV_SIZE chars from passkey\r\n        const repetitons = Math.floor(variables.IV_SIZE/passkey.length);\r\n        const stringVector = ((repetitons === 0)\r\n            ? passkey\r\n            : passkey.repeat(repetitons + 1))\r\n                .substring(0, variables.IV_SIZE);\r\n        \r\n        // Create a Uint8Array iv from string\r\n        const bitVector = new TextEncoder().encode(stringVector);\r\n\r\n        return { name: variables.ALGO, iv: bitVector};\r\n    }\r\n    catch ({ message }) { logError(message as string); };\r\n};\r\n\r\n\r\nexport default getAlgorithm;","import logError from 'utils/logError';\r\n\r\nconst reader = new FileReader();\r\n\r\n// Get the binary file data\r\nconst getFileChunk = (file: File, start: number, end: number) =>\r\n{\r\n\r\n    return new Promise((resolve, _reject) =>\r\n    {\r\n        try\r\n        {\r\n            // Get a chunk from the full file\r\n            const chunk = file.slice(start, end);\r\n\r\n            // Read the chunk\r\n            reader.readAsArrayBuffer(chunk);\r\n            reader.onloadend = (event) =>\r\n            {\r\n                if(event.target && event.target.readyState === FileReader.DONE)\r\n                {\r\n                    const arrayBufferChunk = event.target.result;\r\n                    const uint8Chunk = new Uint8Array(arrayBufferChunk as ArrayBufferLike);\r\n\r\n                    // Return the Uint8Array of the chunk\r\n                    resolve(uint8Chunk);\r\n                };\r\n            };\r\n        }\r\n        catch ({ message }) { logError(message as string); };\r\n    });\r\n};\r\n\r\n\r\nexport default getFileChunk;","\r\nimport logError from 'utils/logError';\r\nimport variables from 'env/variables';\r\n\r\n\r\nconst shouldRepeat = (fileSize: number, end: number) =>\r\n{\r\n    try\r\n    {\r\n        if(fileSize > end) {\r\n            const newEnd = end + variables.CHUNK_SIZE;\r\n            const start = end; end = fileSize > newEnd ? newEnd : fileSize;\r\n            return [true, start, end];\r\n        }\r\n        else return [false, undefined, undefined];\r\n    }\r\n    catch ({ message })\r\n    {\r\n        logError(message as string);\r\n        return [false, undefined, undefined];\r\n    };\r\n};\r\n\r\n\r\nexport default shouldRepeat;","import { createWriteStream } from 'streamsaver';\r\n\r\nimport deriveKey from 'utils/deriveKey';\r\nimport getAlgorithm from 'utils/getAlgorithm';\r\nimport getFileChunk from 'utils/getFileChunk';\r\nimport logError from 'utils/logError';\r\nimport shouldRepeat from 'utils/shouldRepeat';\r\n\r\nimport variables from 'env/variables';\r\n\r\n\r\n// Encrypt any uint8array with a crypto key and algorithm\r\nconst encryptData = async (\r\n    unencryptedData: Uint8Array, key: CryptoKey,\r\n    algorithm: { name: string; iv: Uint8Array; }\r\n) => {\r\n    try\r\n    {\r\n        const encryptedData = await window.crypto.subtle.encrypt(algorithm, key, unencryptedData);\r\n        const encryptedUint8Data = new Uint8Array(encryptedData);\r\n\r\n        return encryptedUint8Data;\r\n    }\r\n    catch ({ message }) { logError(message as string); };\r\n};\r\n\r\n// Encrypt the provided chunk and save it to storage; repeat\r\nconst encryptChunkNSave = async(\r\n    writer: WritableStreamDefaultWriter<any>,\r\n    key: CryptoKey, algorithm: { name: string; iv: Uint8Array; },\r\n    file: File, start: number, end: number\r\n) => {\r\n    try\r\n    {\r\n        // Get file chunk\r\n        const unencryptedChunk = await getFileChunk(file, start, end) as Uint8Array;\r\n\r\n        // Encrypt and write chunk data\r\n        const encryptedChunk = await encryptData(unencryptedChunk, key, algorithm);\r\n\r\n        // Write and continue\r\n        if(encryptedChunk) {\r\n            writer.write(encryptedChunk);\r\n\r\n            const fileSize = file.size + 1;\r\n            const [repeat, newStart, newEnd] = shouldRepeat(fileSize, end);\r\n\r\n            // Repeat if required\r\n            if(repeat) encryptChunkNSave(writer, key, algorithm, file, newStart as number, newEnd as number);\r\n            else writer.close();\r\n        };\r\n    }\r\n    catch ({ message }) { logError(message as string); };\r\n};\r\n\r\n// Initialize encryption with key, algo & filename\r\nconst startEncryption = async (file: File, filename: string, passkey: string) =>\r\n{\r\n    try\r\n    {\r\n        const key = await deriveKey(passkey);\r\n        const algorithm = getAlgorithm(passkey);\r\n\r\n        if(key && algorithm) {\r\n            // Generate a random filename\r\n            const newName = Math.random().toString(36).substring(2);\r\n\r\n            // Create a writable pipeline to storage\r\n            const writableStream = createWriteStream(newName);\r\n            const writer = writableStream.getWriter();\r\n\r\n            const filenameArray = new TextEncoder().encode(filename);\r\n            const encryptedFilename = await encryptData(filenameArray, key, algorithm);\r\n\r\n            if(encryptedFilename) {\r\n                // Writing filename\r\n                const metaDataLen = encryptedFilename.length + 1;\r\n                const metaData = new Uint8Array([...[metaDataLen], ...encryptedFilename])\r\n\r\n                // Start writing encrypted filename\r\n                writer.write(metaData);\r\n\r\n                // Start encrypting file data\r\n                const start = 0, end = variables.CHUNK_SIZE;\r\n                encryptChunkNSave(writer, key, algorithm, file, start, end);\r\n            }\r\n            else logError('Filename encryption failed!');\r\n        }\r\n        else logError('Key generation failed!');\r\n    }\r\n    catch ({ message }) { logError(message as string); };\r\n};\r\n\r\n\r\nexport default startEncryption;","import { createWriteStream } from 'streamsaver';\r\n\r\nimport deriveKey from 'utils/deriveKey';\r\nimport getAlgorithm from 'utils/getAlgorithm';\r\nimport getFileChunk from 'utils/getFileChunk';\r\nimport logError from 'utils/logError';\r\nimport shouldRepeat from 'utils/shouldRepeat';\r\n\r\nimport variables from 'env/variables';\r\n\r\n\r\n// Decrypt any uint8array with a crypto key and algorithm\r\nconst decryptData = async (\r\n    encryptedData: Uint8Array, key: CryptoKey,\r\n    algorithm: { name: string; iv: Uint8Array; }\r\n) => {\r\n    try\r\n    {\r\n        const decryptedData = await window.crypto.subtle.decrypt(algorithm, key, encryptedData);\r\n        const decryptedUint8Data = new Uint8Array(decryptedData);\r\n\r\n        return decryptedUint8Data;\r\n    }\r\n    catch ({ message }) { logError(message as string); };\r\n};\r\n\r\n\r\n// Decrypt the provided chunk and save it to storage; repeat\r\nconst decryptChunkNSave = async (\r\n    writer: WritableStreamDefaultWriter<any>,\r\n    key: CryptoKey, algorithm: { name: string; iv: Uint8Array; },\r\n    file: File, start: number, end: number\r\n) => {\r\n    try\r\n    {\r\n        // Get encrypted file chunk\r\n        const encryptedChunk = await getFileChunk(file, start, end);\r\n\r\n        // Decrypt file chunk\r\n        const decryptedChunk = await decryptData(encryptedChunk as Uint8Array, key, algorithm);\r\n\r\n        // Write and continue\r\n        if(decryptedChunk) {\r\n            writer.write(decryptedChunk);\r\n\r\n            // Check operation status and update variables\r\n            const fileSize = file.size + 1;\r\n            const [repeat, newStart, newEnd] = shouldRepeat(fileSize, end);\r\n            const paddedEnd = newEnd as number + variables.PADDING;\r\n\r\n            // Repeat if required\r\n            if(repeat) decryptChunkNSave(writer, key, algorithm, file, newStart as number, paddedEnd);\r\n            else writer.close();\r\n        };\r\n    }\r\n    catch ({ message }) { logError(message as string); };\r\n};\r\n\r\n\r\n// Initialize decryption with key, algo & filename\r\nconst startDecryption = async (file: File, passkey: string) =>\r\n{\r\n    try\r\n    {\r\n        const key = await deriveKey(passkey);\r\n        const algorithm = getAlgorithm(passkey);\r\n\r\n        if(key && algorithm) {\r\n\r\n            // Extract and decrypt filename array\r\n            const metaDataLen = (await getFileChunk(file, 0, 1) as Uint8Array)[0];\r\n            const encryptedFilename = await getFileChunk(file, 1, metaDataLen);\r\n            const decryptedFilenameArray = await decryptData(encryptedFilename as Uint8Array, key, algorithm);\r\n\r\n            if(decryptedFilenameArray) {\r\n\r\n                // Convert filename Uint8array to string\r\n                const filename = new TextDecoder().decode(decryptedFilenameArray);\r\n\r\n                // Create a writable pipeline to storage\r\n                const writableStream = createWriteStream(filename);\r\n                const writer = writableStream.getWriter();\r\n\r\n                // Start encrypting file data\r\n                const start = metaDataLen, end = metaDataLen + variables.CHUNK_SIZE + variables.PADDING;\r\n                decryptChunkNSave(writer, key, algorithm, file, start, end);\r\n            };\r\n        }\r\n        else logError('Key generation failed!');\r\n    }\r\n    catch ({ message }) { logError(message as string); };\r\n};\r\n\r\n\r\nexport default startDecryption;","\r\nimport React, { useState } from 'react';\r\n\r\nimport logo from 'logo.svg';\r\nimport startEncryption from 'helpers/encryptFile';\r\nimport startDecryption from 'helpers/decryptFile';\r\n\r\n\r\nconst Cipher = () =>\r\n{\r\n    const [file, setFile] = useState<\"\" | File>('');\r\n    const [filename, setFilename] = useState('Choose A File');\r\n    const [passkey, setPasskey] = useState('');\r\n\r\n    const onFileChange = (event: React.ChangeEvent<HTMLInputElement>) =>\r\n    {\r\n        if(event?.target?.files![0]) {\r\n            setFile(event.target.files![0]);\r\n            setFilename(event.target.files![0].name);\r\n        };\r\n    };\r\n\r\n    const onKeyChange = (event: React.ChangeEvent<HTMLInputElement>) => { setPasskey(event.target.value); };\r\n\r\n    const clickFileInput = (e: React.KeyboardEvent<HTMLLabelElement>) =>\r\n    {\r\n        if(e.key === ' ' || e.key === ' ')\r\n            document.getElementById('file')?.click();\r\n    };\r\n\r\n    const encrypt = () =>\r\n    {\r\n        if(file !== '' && passkey !== '') startEncryption(file, filename, passkey);\r\n        else alert('Please provide a file and a passkey in order to encrypt!');\r\n    };\r\n\r\n    const decrypt = () =>\r\n    {\r\n        if(file !== '' && passkey !== '') startDecryption(file, passkey);\r\n        else alert('Please provide a file and a passkey in order to decrypt!');\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <img src={ logo } className='logo' alt=\"logo\" />\r\n            <h1> Cipher </h1>\r\n\r\n            <div className=\"division\"><hr /></div>\r\n            <br /><br /><br />\r\n\r\n            <div className=\"main\">\r\n                <form onSubmit={ event => event.preventDefault() }>\r\n                    <div>\r\n                        <label htmlFor=\"file\" id=\"file-label\" tabIndex={0} onKeyPress={ clickFileInput } >\r\n                            {\r\n                                file === ''\r\n                                    ? 'Choose a File'\r\n                                    : `${ filename.substring(0, 30) }${ filename.length > 30 ? '...' : '' }`\r\n                            }\r\n                            <input type='file' id=\"file\" name=\"file\" onChange={ onFileChange } />\r\n                        </label>\r\n                        <br /><br /><br />\r\n\r\n                        <label id=\"passkey-label\" htmlFor=\"key\">\r\n                            Passkey :\r\n                            <input type='text' id=\"key\" name=\"key\" onChange={ onKeyChange } placeholder={ passkey } />\r\n                        </label>\r\n                    </div>\r\n\r\n                    <input type='button' value='Encrypt' onClick={ encrypt } />\r\n                    <input type='button' value='Decrypt' onClick={ decrypt } />\r\n                </form>\r\n\r\n                <div className=\"instructions\">\r\n                    <h2>Instructions:</h2>\r\n\r\n                    <ol>\r\n                        <li>Select a file.</li>\r\n                        <li>Write any passkey to encrypt/decrypt the file against.</li>\r\n                        <li>Encrypt or Decrypt your file. It's that easy!</li>\r\n                    </ol>\r\n\r\n                    <p>Note: Only the passkey used to encrypt a file can be used to decrypt the same.</p>\r\n                </div>\r\n                <br />\r\n\r\n                No copyrights &#128521;\r\n            </div>\r\n        </>\r\n\r\n    );\r\n};\r\n\r\n\r\nexport default Cipher;","\r\n// Components\r\nimport Cipher from 'components/Cipher';\r\n\r\n\r\nconst App = () =>\r\n  {\r\n      return (\r\n        <div className=\"App\">\r\n          <Cipher />\r\n        </div>\r\n      );\r\n  };\r\n\r\nexport default App;","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\n\r\nimport reportWebVitals from 'reportWebVitals';\r\nimport App from 'App';\r\nimport 'index.css';\r\n\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();"],"sourceRoot":""}